

import { NextRequest, NextResponse } from 'next/server';
import { getOrganizationByWhatsAppNumber, getUserByPhone, addTicket, addAutoGeneratedUser, getOpenTicketsByUserId, addConversation, createNotification, getUserByName, getUsers } from '@/lib/firestore';
import { Twilio } from 'twilio';
import { storage } from '@/lib/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { Attachment } from '@/lib/data';

async function fetchAndUploadMedia(mediaUrl: string, ticketId: string, contentType: string): Promise<Attachment | null> {
    try {
        const response = await fetch(mediaUrl);
        if (!response.ok) {
            console.error(`Failed to fetch Twilio media from ${mediaUrl}. Status: ${response.status}`);
            return null;
        }
        const fileBuffer = await response.arrayBuffer();

        // Extract filename or create a unique one
        const urlParts = mediaUrl.split('/');
        const twilioFileName = urlParts[urlParts.length - 1];
        const fileName = `${Date.now()}-${twilioFileName}`;
        const filePath = `ticket-attachments/${ticketId}/${fileName}`;
        
        const storageRef = ref(storage, filePath);
        await uploadBytes(storageRef, fileBuffer, { contentType });
        const downloadURL = await getDownloadURL(storageRef);

        return {
            name: fileName,
            url: downloadURL,
            type: contentType,
            size: fileBuffer.byteLength,
        };
    } catch (error) {
        console.error(`Error processing media from ${mediaUrl}:`, error);
        return null;
    }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.formData();
    
    const from = body.get('From') as string; // e.g., whatsapp:+14155238886
    const to = body.get('To') as string;     // e.g., whatsapp:+1234567890
    const messageBody = body.get('Body') as string;
    const profileName = body.get('ProfileName') as string;
    const accountSid = body.get('AccountSid') as string;
    const numMedia = parseInt(body.get('NumMedia') as string || '0', 10);

    if (!from || (!messageBody && numMedia === 0) || !to) {
        return NextResponse.json({ error: 'Missing required fields from webhook.' }, { status: 400 });
    }

    const clientPhoneNumber = from.replace('whatsapp:', '');
    const businessPhoneNumber = to.replace('whatsapp:', '');

    // 1. Find the organization by the business phone number
    const organization = await getOrganizationByWhatsAppNumber(businessPhoneNumber);
    if (!organization) {
        console.warn(`Webhook received for an unconfigured WhatsApp number: ${businessPhoneNumber}`);
        return NextResponse.json({ error: `WhatsApp number ${businessPhoneNumber} is not configured for any organization.` }, { status: 404 });
    }

    // 2. Validate the request is from the correct Twilio account
    if (organization.settings?.whatsapp?.accountSid !== accountSid) {
        console.error(`Request SID ${accountSid} does not match configured SID ${organization.settings?.whatsapp?.accountSid}`);
        return NextResponse.json({ error: 'Invalid AccountSid. Request ignored.' }, { status: 403 });
    }

    // 3. Find or create the user by their phone number
    let user = await getUserByPhone(clientPhoneNumber, organization.id);

    if (!user) {
        console.log(`User not found for phone number ${clientPhoneNumber}. Creating a new user.`);
        const initials = profileName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
        const avatar = `https://placehold.co/32x32/A2E9C1/4A4A4A.png?text=${initials}`;
        
        const newUserData = {
            name: profileName || `WhatsApp User ${clientPhoneNumber}`,
            email: '', 
            phone: clientPhoneNumber,
            role: 'Client' as const,
            avatar,
            organizationId: organization.id,
            status: 'active' as const,
            activityIsPublic: false,
            createdByAdmin: false,
            country: '',
            city: '',
            zipCode: '',
            dob: '',
            gender: 'Prefer not to say' as const,
        };
        
        const newUserId = await addAutoGeneratedUser(newUserData);
        user = { ...newUserData, id: newUserId };
        console.log(`Created new user ${user.name} with ID ${user.id}`);
    } else {
      console.log(`Found existing user: ${user.name} (ID: ${user.id})`);
    }
    
    // 4. Check for existing open tickets for this user
    const openTickets = await getOpenTicketsByUserId(user.id);

    if (openTickets.length > 0) {
        const ticketToUpdate = openTickets[0];
        console.log(`Appending reply to existing open ticket: ${ticketToUpdate.id}`);

        const attachments: Attachment[] = [];
        if (numMedia > 0) {
            for (let i = 0; i < numMedia; i++) {
                const mediaUrl = body.get(`MediaUrl${i}`) as string;
                const contentType = body.get(`MediaContentType${i}`) as string;
                if (mediaUrl && contentType) {
                    const attachment = await fetchAndUploadMedia(mediaUrl, ticketToUpdate.id, contentType);
                    if (attachment) {
                        attachments.push(attachment);
                    }
                }
            }
        }
        
        await addConversation(
            ticketToUpdate.id,
            { 
                content: messageBody, 
                authorId: user.id,
                authorName: user.name,
                attachments: attachments,
            }
        );
        
        // Notify the assignee and all admins
        const userIdsToNotify = new Set<string>();
        if (ticketToUpdate.assignee && ticketToUpdate.assignee !== 'Unassigned') {
            const assignee = await getUserByName(ticketToUpdate.assignee);
            if (assignee) userIdsToNotify.add(assignee.id);
        }
        const admins = await getUsers({ organizationId: organization.id, role: 'Admin' } as any);
        admins.forEach(admin => userIdsToNotify.add(admin.id));

        const summary = messageBody ? (messageBody.length > 100 ? `${messageBody.substring(0, 97)}...` : messageBody) : `Sent ${numMedia} attachment(s)`;

        if (userIdsToNotify.size > 0) {
            const notificationPromises = Array.from(userIdsToNotify).map(userId => 
                createNotification({
                    userId: userId,
                    title: `New reply from ${user.name}`,
                    description: summary,
                    link: `/tickets/view/${ticketToUpdate.id}`,
                    type: 'new_reply',
                    metadata: { from: user.name, ticketTitle: ticketToUpdate.title }
                })
            );
            await Promise.all(notificationPromises);
        }
        
        console.log(`Successfully appended reply to ticket ${ticketToUpdate.id}`);
        return NextResponse.json({ success: true, message: `Appended reply to ticket ${ticketToUpdate.id}` });

    } else {
        // 5. Create a new ticket if no open tickets exist
        console.log(`No open tickets found. Creating a new ticket for user ${user.name}.`);
        // First, create the ticket to get an ID
        const initialTicketData = {
            title: `New WhatsApp Message from ${user.name}`,
            description: messageBody,
            reporter: user.name,
            reporterId: user.id,
            reporterPhone: clientPhoneNumber,
            tags: ['whatsapp'],
            priority: 'Medium' as const,
            category: 'General' as const,
            assignee: 'Unassigned',
            project: null,
            source: 'WhatsApp' as const,
            organizationId: organization.id,
            statusLastSetBy: 'System' as const,
            priorityLastSetBy: 'System' as const,
            status: 'New' as const,
        };
        const newTicketId = await addTicket(initialTicketData);

        // Now process attachments with the new ticket ID
        const attachments: Attachment[] = [];
        if (numMedia > 0) {
            for (let i = 0; i < numMedia; i++) {
                const mediaUrl = body.get(`MediaUrl${i}`) as string;
                const contentType = body.get(`MediaContentType${i}`) as string;
                if (mediaUrl && contentType) {
                    const attachment = await fetchAndUploadMedia(mediaUrl, newTicketId, contentType);
                    if (attachment) {
                        attachments.push(attachment);
                    }
                }
            }
            // Update the ticket description to include a note about the attachments and add them to the ticket
            const attachmentNote = `\n\n--- Attachments ---\n${attachments.map(a => a.name).join('\n')}`;
            await addConversation(newTicketId, {
                content: initialTicketData.description,
                authorId: user.id,
                authorName: user.name,
                attachments: attachments,
            });
        }
        
        console.log(`Successfully created new ticket ${newTicketId}`);

        // 6. Send confirmation reply via Twilio ONLY for new tickets
        const twilioClient = new Twilio(organization.settings.whatsapp.accountSid, organization.settings.whatsapp.authToken);
        
        const template = `Thanks for contacting us, {{user.name}}! We've received your message and created ticket #${newTicketId.substring(0,6)}. An agent will be with you shortly.`;
        
        const replyBody = template
            .replace('{{user.name}}', user.name)
            .replace('{{ticket.id}}', newTicketId.substring(0, 6));

        await twilioClient.messages.create({
            from: to,
            to: from,
            body: replyBody,
        });
        console.log(`Sent confirmation message to ${user.name} for ticket ${newTicketId}`);

        return NextResponse.json({ success: true, ticketId: newTicketId });
    }

  } catch (error) {
    console.error('Error processing Twilio inbound WhatsApp message:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json({ error: 'Failed to process message.', details: errorMessage }, { status: 500 });
  }
}
